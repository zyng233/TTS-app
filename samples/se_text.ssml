<speak>
  <p>
    <prosody rate="medium" pitch="+10%">Let's explore the fundamental design patterns every developer should know</prosody>
    <break time="500ms"/>
    Today we'll examine four essential patterns: the Singleton, Observer, Factory Method, and Strategy patterns - 
    <break time="300ms"/>
    powerful tools that help create clean, maintainable, and flexible software architectures.
  </p>
  <break time="500ms"/>

  <p>
    The <prosody rate="slow">Singleton pattern</prosody> ensures that only one instance of a class exists throughout your application's lifecycle.
    <break time="300ms"/>
    Think of it like a building manager who controls access to shared resources - there's only one person authorized to distribute the master keys.
    <break time="400ms"/>
    This pattern implements three key components: a private constructor to prevent external instantiation, a static variable to hold the single instance, and a public getInstance() method that provides controlled access.
  </p>
  <break time="600ms"/>

  <p>
    The <prosody pitch="+15%">Observer pattern</prosody> establishes a publish-subscribe mechanism for event notifications.
    <break time="300ms"/>
    Much like subscribing to a newsletter, objects can register as observers and receive automatic updates whenever the subject's state changes.
    <break time="400ms"/>
    This pattern is particularly valuable in modern UI frameworks where components need to react to state changes, and in distributed systems that require real-time synchronization between services.
  </p>
  <break time="600ms"/>

  <p>
    The <prosody pitch="+10%">Factory Method pattern</prosody> delegates object creation to specialized subclasses.
    <break time="300ms"/>
    Imagine ordering at a restaurant - you request a meal from the menu (the interface), while the kitchen (the factory implementation) determines exactly how to prepare your dish.
    <break time="400ms"/>
    Major frameworks like Spring for Java applications and Android's UI system utilize this pattern extensively to manage object creation.
  </p>
  <break time="600ms"/>

  <p>
    The <prosody pitch="+10%">Strategy pattern</prosody> enables you to define interchangeable algorithms that can be selected at runtime.
    <break time="300ms"/>
    Consider how navigation apps offer different route options - you might choose between the fastest, most scenic, or most fuel-efficient path, while the basic navigation functionality remains consistent.
    <break time="400ms"/>
    This pattern shines in systems requiring multiple processing options, such as payment gateways that support credit cards, digital wallets, and cryptocurrency transactions.
  </p>
  <break time="600ms"/>

  <p>
    <prosody rate="slow">As we conclude, remember these key principles:</prosody>
    <break time="300ms"/>
    Design patterns emerge as proven solutions to recurring software development challenges,
    <break time="250ms"/>
    they should be applied thoughtfully rather than treated as universal requirements,
    <break time="250ms"/>
    and they must evolve alongside your application's changing needs.
    <break time="400ms"/>
    By mastering these four foundational patterns, you'll be equipped to design more robust, adaptable software systems.
  </p>
</speak>