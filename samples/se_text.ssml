<speak>
  <!-- Introduction -->
  <p>
    <prosody rate="1.05" pitch="+1st">Mastering Core Design Patterns</prosody>
    <break time="500ms"/>
    Today we'll explore four fundamental patterns every software engineer needs:
    <break time="300ms"/>
    <emphasis>Singleton</emphasis>, 
    <emphasis>Observer</emphasis>,  
    <emphasis>Factory</emphasis>, and
    <emphasis>Strategy</emphasis>.
    <break time="700ms"/>
  </p>

  <!-- Singleton -->
  <p>
    <sub alias="Singleton">Singleton</sub> ensures <break time="300ms"/>
    <prosody rate="0.9" pitch="-1st">exactly one instance</prosody> of a class exists system-wide.
    <break time="500ms"/>
    <prosody rate="1.0">Key characteristics:</prosody>
    <break time="300ms"/>
    <prosody rate="0.85">
      - Private constructor <break strength="weak"/>
      - Static instance variable <break strength="weak"/>
      - Global access point via <say-as interpret-as="verbatim">getInstance()</say-as>
    </prosody>
    <break time="600ms"/>
    <prosody rate="0.9">
      Real-world analogy: <break strength="x-weak"/>
      A company's <emphasis>CEO position</emphasis> - there's only one official holder at any time.
    </prosody>
    <break time="800ms"/>
  </p>

  <!-- Observer -->
  <p>
    The <sub alias="Observer">Observer</sub> pattern implements
    <prosody pitch="+2st">publish-subscribe</prosody> mechanisms.
    <break time="500ms"/>
    Component breakdown:
    <break time="300ms"/>
    <prosody rate="0.9">
      1. <say-as interpret-as="verbatim">Subject</say-as>: Maintains observer list <break strength="weak"/>
      2. <say-as interpret-as="verbatim">Observers</say-as>: Implement update protocol
    </prosody>
    <break time="600ms"/>
    <prosody rate="1.0">Modern applications:</prosody>
    <break time="300ms"/>
    <prosody rate="0.9">
      - React.js state management <break strength="weak"/>
      - IoT device coordination <break strength="weak"/>
      - Stock market data feeds
    </prosody>
    <break time="800ms"/>
  </p>

  <!-- Factory -->
  <p>
    <sub alias="Factory Method">Factory Method</sub> solves the
    <break time="300ms"/> 
    <emphasis>object creation</emphasis> problem through inheritance.
    <break time="500ms"/>
    Implementation phases:
    <break time="300ms"/>
    <prosody rate="0.9">
      1. Define creator interface <break strength="weak"/>
      2. Implement concrete creators <break strength="weak"/>
      3. Defer instantiation to subclasses
    </prosody>
    <break time="600ms"/>
    <prosody rate="1.0">Framework examples:</prosody>
    <break time="300ms"/>
    <prosody rate="0.9">
      - Spring's <say-as interpret-as="verbatim">BeanFactory</say-as> <break strength="weak"/>
      - Android's <say-as interpret-as="verbatim">ViewFactory</say-as>
    </prosody>
    <break time="800ms"/>
  </p>

  <!-- Strategy -->
  <p>
    <sub alias="Strategy">Strategy</sub> defines interchangeable algorithms.
    <break time="300ms"/>
    Implementation:
    <break time="300ms"/>
    <prosody rate="0.9">
      1. Declare strategy interface
      2. Create concrete strategies
      3. Context class delegates execution
    </prosody>
    <break time="600ms"/>
    Real-world use:
    <prosody rate="0.9">
      - Payment processors (credit card vs PayPal)
      - Navigation apps (driving vs walking routes)
    </prosody>
    <break time="800ms"/>
  </p>

  <!-- Comparative Analysis -->
  <p>
    <prosody rate="1.1" pitch="-2st">Pattern Comparison:</prosody>
    <break time="500ms"/>
    <prosody rate="0.9">
      - Singleton <break strength="weak"/> controls instance count <break time="200ms"/>
      - Observer <break strength="weak"/> manages state propagation <break time="200ms"/>
      - Factory Method <break strength="weak"/> abstracts creation logic <break time="200ms"/>
      - Strategy <break strength="weak"/> change at runtime
    </prosody>
    <break time="700ms"/>
  </p>

  <!-- Conclusion -->
  <p>
    <prosody rate="0.85">Remember these principles:</prosody>
    <break time="400ms"/>
    <prosody rate="0.9">
      1. Patterns emerge from recurring problems <break strength="weak"/>
      2. Implement judiciously <break strength="weak"/>
      3. Refactor when requirements evolve
    </prosody>
    <break time="500ms"/>
    <emphasis>Great software balances patterns with pragmatism.</emphasis>
  </p>
</speak>